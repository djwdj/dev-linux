#include "WorkerThread.h"#include <stdio.h>int workerThreadInit(struct WorkerThread* thread, int index){	thread->evLoop = NULL;	thread->threadID = 0;	sprintf(thread->name, "SubThread-%d", index);	pthread_mutex_init(&thread->mutex, NULL);  //指定为NULL，表示使用默认属性	pthread_cond_init(&thread->cond, NULL);	return 0;}//子线程的回调函数，子线程运行void* subThreadRunning(void* arg){	//子线程要执行的任务都在反映堆模型的任务队列里面	struct WorkerThread* thread = (struct WorkerThread*)arg;	pthread_mutex_lock(&thread->mutex);	//对evLoop做初始化	thread->evLoop = eventLoopInitEx(thread->name);	pthread_mutex_unlock(&thread->mutex);	pthread_cond_signal(&thread->cond); //主线程的条件变量等待解除阻塞	// 启动反应堆模型	eventLoopRun(thread->evLoop);	return NULL;}void workerThreadRun(struct WorkerThread* thread) //主线程运行{	//创建子线程,3,4子线程的回调函数以及传入的参数	pthread_create(&thread->threadID, NULL, subThreadRunning, thread); 	// 阻塞主线程，让当前函数不会直接结束，不知道当前子线程是否运行结束	// 如果为空，子线程还没有初始化完毕,让主线程等一会，等到初始化完毕	pthread_mutex_lock(&thread->mutex);	while (thread->evLoop == NULL) 	{		pthread_cond_wait(&thread->cond, &thread->mutex);	}	pthread_mutex_unlock(&thread->mutex);}